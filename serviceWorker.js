parcelRequire=function(e){var r="function"==typeof parcelRequire&&parcelRequire,n="function"==typeof require&&require,i={};function u(e,u){if(e in i)return i[e];var t="function"==typeof parcelRequire&&parcelRequire;if(!u&&t)return t(e,!0);if(r)return r(e,!0);if(n&&"string"==typeof e)return n(e);var o=new Error("Cannot find module '"+e+"'");throw o.code="MODULE_NOT_FOUND",o}return u.register=function(e,r){i[e]=r},i=e(u),u.modules=i,u}(function (require) {try{self["workbox:core:4.3.1"]&&_()}catch(e){}const n=(e,...r)=>{let t=e;return r.length>0&&(t+=` :: ${JSON.stringify(r)}`),t},o=n;class i extends Error{constructor(r,e){super(o(r,e)),this.name=r,this.details=e}}try{self["workbox:routing:4.3.1"]&&_()}catch(e){}const p="GET";const g=e=>e&&"object"==typeof e?e:{handle:e};class q{constructor(e,r,s){this.handler=g(r),this.match=e,this.method=s||p}}class r extends q{constructor(e,r,o){super(({url:r})=>{const o=e.exec(r.href);return o?r.origin!==location.origin&&0!==o.index?null:o.slice(1):null},r,o)}}const M={googleAnalytics:"googleAnalytics",precache:"precache-v2",prefix:"workbox",runtime:"runtime",suffix:self.registration.scope};let N;class s{constructor(){this._routes=new Map}get routes(){return this._routes}addFetchListener(){self.addEventListener("fetch",e=>{const{request:t}=e,r=this.handleRequest({request:t,event:e});r&&e.respondWith(r)})}addCacheListener(){self.addEventListener("message",async e=>{if(e.data&&"CACHE_URLS"===e.data.type){const{payload:t}=e.data;0;const r=Promise.all(t.urlsToCache.map(e=>{"string"==typeof e&&(e=[e]);const t=new Request(...e);return this.handleRequest({request:t})}));e.waitUntil(r),e.ports&&e.ports[0]&&(await r,e.ports[0].postMessage(!0))}})}handleRequest({request:e,event:t}){const r=new URL(e.url,location);if(!r.protocol.startsWith("http"))return void 0;let s,{params:o,route:a}=this.findMatchingRoute({url:r,request:e,event:t}),n=a&&a.handler;if(!n&&this._defaultHandler&&(n=this._defaultHandler),n){try{s=n.handle({url:r,request:e,event:t,params:o})}catch(i){s=Promise.reject(i)}return s&&this._catchHandler&&(s=s.catch(e=>this._catchHandler.handle({url:r,event:t,err:e}))),s}}findMatchingRoute({url:e,request:t,event:r}){const s=this._routes.get(t.method)||[];for(const o of s){let s,a=o.match({url:e,request:t,event:r});if(a)return Array.isArray(a)&&a.length>0?s=a:a.constructor===Object&&Object.keys(a).length>0&&(s=a),{route:o,params:s}}return{}}setDefaultHandler(e){this._defaultHandler=g(e)}setCatchHandler(e){this._catchHandler=g(e)}registerRoute(e){this._routes.has(e.method)||this._routes.set(e.method,[]),this._routes.get(e.method).push(e)}unregisterRoute(e){if(!this._routes.has(e.method))throw new i("unregister-route-but-not-found-with-method",{method:e.method});const t=this._routes.get(e.method).indexOf(e);if(!(t>-1))throw new i("unregister-route-route-not-registered");this._routes.get(e.method).splice(t,1)}}class t{constructor(e){this._errors=e}createError(e,r){if(!(e in this._errors))throw new Error(`Unable to generate error '${e}'.`);let t=this._errors[e].replace(/\s+/g," "),s=null;r&&(t+=` [${r.message}]`,s=r.stack);const a=new Error;return a.name=e,a.message=t,a.stack=s,a}}const u={"multiple-cache-will-update-plugins":"You cannot register more than one plugin that implements cacheWillUpdate.","multiple-cached-response-will-be-used-plugins":"You cannot register more than one plugin that implements cachedResponseWillBeUsed.","invalid-response-for-caching":"The fetched response could not be cached due to an invalid response code.","no-response-received":"No response received; falling back to cache.","bad-cache-id":"The 'cacheId' parameter must be a string with at least one character."};var d=new t(u),v={parse:()=>[]};function h(e){const r=Object.keys(e);r.some(r=>void 0!==e[r])||c("Please set at least one of the following parameters: "+r.map(e=>`'${e}'`).join(", "))}function a(e,r){const t=Object.keys(e).pop();e[t]instanceof r||c(`The '${t}' parameter must be an instance of\n      '${r.name}'`)}function f(e,r){const t=Object.keys(e).pop(),s=typeof e[t];s!==r&&c(`The '${t}' parameter has the wrong type. (Expected:\n      ${r}, actual: ${s})`)}function j(e,r){const t=Object.keys(e).pop(),s=`The '${t}' parameter should be an array containing\n    one or more '${r}' elements.`;Array.isArray(e[t])||c(s);for(let a of e[t])typeof a!==r&&c(s)}function c(e){e=e.replace(/\s+/g," ");const r=new Error(e);r.name="assertion-failed";const t=v.parse(r);throw 3<=t.length&&(r.message=`Invalid call to ${t[2].functionName}() â€” `+e),r}class k{constructor(){this._logs=[],this._childGroups=[],this._isFallbackMode=!1;const e=/Firefox\/(\d*)\.\d*/.exec(navigator.userAgent);if(e)try{55>parseInt(e[1],10)&&(this._isFallbackMode=!0)}catch(e){this._isFallbackMode=!0}/Edge\/\d*\.\d*/.exec(navigator.userAgent)&&(this._isFallbackMode=!0)}addPrimaryLog(e){this._primaryLog=e}addLog(e){this._logs.push(e)}addChildGroup(e){0===e._logs.length||this._childGroups.push(e)}print(){return 0===this._logs.length&&0===this._childGroups.length?void this._printLogDetails(this._primaryLog):(this._primaryLog&&(this._isFallbackMode?this._printLogDetails(this._primaryLog):console.groupCollapsed(...this._getLogContent(this._primaryLog))),this._logs.forEach(e=>{this._printLogDetails(e)}),this._childGroups.forEach(e=>{e.print()}),void(this._primaryLog&&!this._isFallbackMode&&console.groupEnd()))}_printLogDetails(e){(e.logFunc?e.logFunc:console.log)(...this._getLogContent(e))}_getLogContent(e){let r=e.message;this._isFallbackMode&&"string"==typeof r&&(r=r.replace(/%c/g,""));let t=[r];return!this._isFallbackMode&&e.colors&&(t=t.concat(e.colors)),e.args&&(t=t.concat(e.args)),t}}function w(){return!1}self.workbox=self.workbox||{},self.workbox.LOG_LEVEL=self.workbox.LOG_LEVEL||{none:-1,verbose:0,debug:1,warn:2,error:3};const l="#bdc3c7",x="#7f8c8d",y="#2ecc71",z="#f1c40f",A="#e74c3c",B="#3498db";class C{constructor(){this._defaultLogLevel=w()?self.workbox.LOG_LEVEL.debug:self.workbox.LOG_LEVEL.warn}log(e){this._printMessage(self.workbox.LOG_LEVEL.verbose,e)}debug(e){this._printMessage(self.workbox.LOG_LEVEL.debug,e)}warn(e){this._printMessage(self.workbox.LOG_LEVEL.warn,e)}error(e){this._printMessage(self.workbox.LOG_LEVEL.error,e)}_printMessage(e,r){if(this._shouldLogMessage(e,r)){this._getAllLogGroups(e,r).print()}}_getAllLogGroups(e,r){const t=new k,s=this._getPrimaryMessageDetails(e,r);if(t.addPrimaryLog(s),r.error){const e={message:r.error,logFunc:console.error};t.addLog(e)}const a=new k;if(r.that&&r.that.constructor&&r.that.constructor.name){const e=r.that.constructor.name;a.addLog(this._getKeyValueDetails("class",e))}return r.data&&("object"!=typeof r.data||r.data instanceof Array?a.addLog(this._getKeyValueDetails("additionalData",r.data)):Object.keys(r.data).forEach(e=>{a.addLog(this._getKeyValueDetails(e,r.data[e]))})),t.addChildGroup(a),t}_getKeyValueDetails(e,r){return{message:`%c${e}: `,colors:[`color: ${B}`],args:r}}_getPrimaryMessageDetails(e,r){let t,s;e===self.workbox.LOG_LEVEL.verbose?(t="Info",s=l):e===self.workbox.LOG_LEVEL.debug?(t="Debug",s=y):e===self.workbox.LOG_LEVEL.warn?(t="Warn",s=z):e===self.workbox.LOG_LEVEL.error&&(t="Error",s=A);let a=`%cðŸ”§ %c[${t}]`;const o=[`color: ${l}`,`color: ${s}`];let n;return"string"==typeof r?n=r:r.message&&(n=r.message),n&&(a+=`%c ${n=n.replace(/\s+/g," ")}`,o.push(`color: ${x}; font-weight: normal`)),{message:a,colors:o}}_shouldLogMessage(e,r){if(!r)return!1;let t=this._defaultLogLevel;return self&&self.workbox&&"number"==typeof self.workbox.logLevel&&(t=self.workbox.logLevel),!(t===self.workbox.LOG_LEVEL.none||e<t)}}var D=new C;class E{constructor({statuses:e,headers:r}={}){h({statuses:e,headers:r}),void 0!==e&&j({statuses:e},"number"),void 0!==r&&f({headers:r},"object"),this.statuses=e,this.headers=r}isResponseCacheable({request:e,response:r}={}){a({response:r},Response);let t=!0;if(this.statuses&&(t=this.statuses.includes(r.status)),this.headers&&t&&(t=Object.keys(this.headers).some(e=>r.headers.get(e)===this.headers[e])),!t){const t={response:r};this.statuses&&(t["valid-status-codes"]=JSON.stringify(this.statuses)),this.headers&&(t["valid-headers"]=JSON.stringify(this.headers)),e&&(t.request=e),D.debug({message:"The response does not meet the criteria for being added to the\n          cache.",data:t})}return t}}class F extends E{cacheWillUpdate({request:e,response:r}={}){return this.isResponseCacheable({request:e,response:r})}}const G=({cacheId:e}={})=>{let r="workbox-runtime-caching";return e&&(r=`${e}-${r}`),self&&self.registration&&(r+=`-${self.registration.scope}`),r},H=["cacheDidUpdate","cachedResponseWillBeUsed","cacheWillUpdate","fetchDidFail","requestWillFetch"];var I=({response:e})=>{a({response:e},Response);const r=e.clone();return("body"in r?Promise.resolve(r.body):r.blob()).then(e=>new Response(e,{headers:r.headers,status:r.status,statusText:r.statusText}))},b=function(e){return function(){var r=e.apply(this,arguments);return new Promise(function(e,t){return function s(a,o){try{var n=r[a](o),c=n.value}catch(i){return void t(i)}if(!n.done)return Promise.resolve(c).then(function(e){s("next",e)},function(e){s("throw",e)});e(c)}("next")})}};class J{constructor({cacheName:e,cacheId:r,plugins:t,fetchOptions:s,matchOptions:a}={}){if(r&&("string"!=typeof r||0===r.length))throw d.createError("bad-cache-id");e?(f({cacheName:e},"string"),this.cacheName=e,r&&(this.cacheName=`${r}-${this.cacheName}`)):this.cacheName=G({cacheId:r}),s&&(f({fetchOptions:s},"object"),this.fetchOptions=s),a&&(f({matchOptions:a},"object"),this.matchOptions=a),this.plugins=new Map,t&&(j({plugins:t},"object"),t.forEach(e=>{for(let r of H)if("function"==typeof e[r]){if(this.plugins.has(r)){if("cacheWillUpdate"===r)throw d.createError("multiple-cache-will-update-plugins");if("cachedResponseWillBeUsed"===r)throw d.createError("multiple-cached-response-will-be-used-plugins")}else this.plugins.set(r,[]);this.plugins.get(r).push(e)}})),this.plugins.has("cacheWillUpdate")&&(this._userSpecifiedCachableResponsePlugin=this.plugins.get("cacheWillUpdate")[0])}getDefaultCacheableResponsePlugin(){return this._defaultCacheableResponsePlugin||(this._defaultCacheableResponsePlugin=new F({statuses:[200]})),this._defaultCacheableResponsePlugin}getCache(){var e=this;return b(function*(){return e._cache||(e._cache=yield caches.open(e.cacheName)),e._cache})()}match({request:e}){var r=this;return b(function*(){h({request:e});const t=yield r.getCache();let s=yield t.match(e,r.matchOptions);if(r.plugins.has("cachedResponseWillBeUsed")){const a=r.plugins.get("cachedResponseWillBeUsed")[0];s=yield a.cachedResponseWillBeUsed({request:e,cache:t,cachedResponse:s,matchOptions:r.matchOptions,cacheName:r.cacheName})}return s})()}fetch({request:e}){var r=this;return b(function*(){"string"==typeof e?e=new Request(e):a({request:e},Request);const t=r.plugins.has("fetchDidFail")?e.clone():null;if(r.plugins.has("requestWillFetch"))for(let s of r.plugins.get("requestWillFetch")){const r=yield s.requestWillFetch({request:e});a({returnedRequest:r},Request),e=r}try{return yield fetch(e,r.fetchOptions)}catch(e){if(r.plugins.has("fetchDidFail"))for(let e of r.plugins.get("fetchDidFail"))yield e.fetchDidFail({request:t.clone()});throw e}})()}fetchAndCache({request:e,waitOnCache:r,cacheKey:t,cacheResponsePlugin:s,cleanRedirects:a}){var o=this;return b(function*(){let n;h({request:e});const c=yield o.fetch({request:e}),i=o._userSpecifiedCachableResponsePlugin||s||o.getDefaultCacheableResponsePlugin(),l=yield i.cacheWillUpdate({request:e,response:c});if(l){const r=a&&c.redirected?yield I({response:c}):c.clone();n=o.getCache().then((()=>{var s=b(function*(s){let a;const n=t||e;if("opaque"!==c.type&&o.plugins.has("cacheDidUpdate")&&(a=yield o.match({request:n})),yield s.put(n,r),o.plugins.has("cacheDidUpdate"))for(let e of o.plugins.get("cacheDidUpdate"))yield e.cacheDidUpdate({cacheName:o.cacheName,oldResponse:a,newResponse:r,url:"url"in n?n.url:n})});return function(){return s.apply(this,arguments)}})())}else if(!l&&r)throw d.createError("invalid-response-for-caching");return r&&n&&(yield n),c})()}}class K{constructor({requestWrapper:e,waitOnCache:r}={}){this.requestWrapper=e||new J,this.waitOnCache=!!r}handle({event:e,params:r}={}){throw Error("This abstract method must be implemented in a subclass.")}}class e extends K{handle({event:e}={}){var r=this;return b(function*(){return a({event:e},FetchEvent),(yield r.requestWrapper.match({request:e.request}))||(yield r.requestWrapper.fetchAndCache({request:e.request,waitOnCache:r.waitOnCache}))})()}}console.log(new RegExp("/.*/i"));const L=new r({regExp:new RegExp("/.*/i"),handler:new e}),m=new s;m.registerRoutes({routes:[L]}),m.setDefaultHandler({handler:new e});return{"oXuJ":{}};});